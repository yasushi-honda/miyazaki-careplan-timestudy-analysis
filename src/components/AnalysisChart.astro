---
// クライアントサイドのみで実行するチャートコンポーネント
const { id = 'analysisChart', chartType = 'bar', beforeData = {}, afterData = {}, labels, beforeLabel = '導入前', afterLabel = '導入後', yAxisLabel = '', xAxisLabel = '', chartTitle = '' } = Astro.props;
---

<div class="chart-container">
  <canvas id={id}></canvas>
</div>

<script define:vars={{ id, chartType, beforeData, afterData, labels, beforeLabel, afterLabel, yAxisLabel, xAxisLabel, chartTitle }}>
// チャートインスタンスを保持する変数
let chartInstance = null;

// チャートを初期化または更新する関数
function initOrUpdateChart(beforeDataInput, afterDataInput) {
  try {
    console.log('チャート初期化/更新開始:', id);
    console.log('beforeData:', JSON.stringify(beforeDataInput));
    console.log('afterData:', JSON.stringify(afterDataInput));
    
    // 日本語文字列を安全に使うため、クライアントサイドでのみ設定
    const safeLabels = ["FAX", "メール", "持参", "郵送", "システム", "その他"];
    
    // データの準備
    let beforeValues = [];
    let afterValues = [];
    
    // データ形式に応じた処理
    if (Array.isArray(labels)) {
      // 指定されたラベルを使用
      safeLabels.forEach(label => {
        beforeValues.push(parseFloat(beforeDataInput[label] || 0));
        afterValues.push(parseFloat(afterDataInput[label] || 0));
      });
    } else {
      // デフォルトの共有方法を使用
      beforeValues = [
        parseFloat(beforeDataInput["FAX"] || 0),
        parseFloat(beforeDataInput["メール"] || 0),
        parseFloat(beforeDataInput["持参"] || 0),
        parseFloat(beforeDataInput["郵送"] || 0),
        parseFloat(beforeDataInput["システム"] || 0),
        parseFloat(beforeDataInput["その他"] || 0)
      ];
      
      afterValues = [
        parseFloat(afterDataInput["FAX"] || 0),
        parseFloat(afterDataInput["メール"] || 0),
        parseFloat(afterDataInput["持参"] || 0),
        parseFloat(afterDataInput["郵送"] || 0),
        parseFloat(afterDataInput["システム"] || 0),
        parseFloat(afterDataInput["その他"] || 0)
      ];
    }
    
    console.log('処理後のデータ:', { safeLabels, beforeValues, afterValues });
    
    // チャート設定
    const chartConfig = {
      type: chartType,
      data: {
        labels: safeLabels,
        datasets: [
          {
            label: beforeLabel,
            data: beforeValues,
            backgroundColor: 'rgba(75, 192, 192, 0.5)',
            borderColor: 'rgba(75, 192, 192, 1)',
            borderWidth: 1
          },
          {
            label: afterLabel,
            data: afterValues,
            backgroundColor: 'rgba(153, 102, 255, 0.5)',
            borderColor: 'rgba(153, 102, 255, 1)',
            borderWidth: 1
          }
        ]
      },
      options: {
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          y: {
            beginAtZero: true,
            title: {
              display: true,
              text: yAxisLabel
            }
          },
          x: {
            title: {
              display: true,
              text: xAxisLabel
            }
          }
        },
        plugins: {
          title: {
            display: !!chartTitle,
            text: chartTitle
          },
          legend: {
            position: 'top',
          }
        }
      }
    };
    
    const canvas = document.getElementById(id);
    if (canvas) {
      console.log('キャンバス要素が見つかりました:', id);
      if (typeof Chart !== 'undefined') {
        console.log('Chart.jsが利用可能です');
        
        // 既存のチャートがあれば破棄
        if (chartInstance) {
          chartInstance.destroy();
        }
        
        // 新しいチャートを作成
        chartInstance = new Chart(canvas.getContext('2d'), chartConfig);
        console.log('チャートが正常に初期化されました:', id);
      } else {
        console.error('Chart.jsが読み込まれていません');
      }
    } else {
      console.error(`キャンバス要素が見つかりません: "${id}"`);
    }
  } catch (error) {
    console.error('チャート初期化エラー:', error);
  }
}

// DOMが読み込まれたらチャートを初期化
document.addEventListener('DOMContentLoaded', () => {
  // 初期データでチャートを初期化
  initOrUpdateChart(beforeData, afterData);
  
  // CSVデータが読み込まれたときのイベントリスナー
  window.addEventListener('csv-data-loaded', (event) => {
    console.log('CSVデータ読み込みイベント検知:', event.detail.fileName);
    
    // 必要なCSVファイルが読み込まれたら、チャートを更新
    if (window.__csvDataCache) {
      const newBeforeData = {};
      const newAfterData = {};
      
      // 事業所データの場合
      if (id.includes('business')) {
        if (window.__csvDataCache['business_before.csv'] && window.__csvDataCache['business_after.csv']) {
          console.log('事業所データでチャートを更新します');
          
          // 事業所データの集計処理
          const beforeDataArray = window.__csvDataCache['business_before.csv'];
          const afterDataArray = window.__csvDataCache['business_after.csv'];
          
          // ここでデータを集計
          // 例: 共有方法ごとの平均時間を計算
          newBeforeData["FAX"] = calculateAverageByMethod(beforeDataArray, "FAX");
          newBeforeData["メール"] = calculateAverageByMethod(beforeDataArray, "メール");
          newBeforeData["持参"] = calculateAverageByMethod(beforeDataArray, "持参");
          newBeforeData["郵送"] = calculateAverageByMethod(beforeDataArray, "郵送");
          newBeforeData["システム"] = calculateAverageByMethod(beforeDataArray, "システム");
          newBeforeData["その他"] = calculateAverageByMethod(beforeDataArray, "その他");
          
          newAfterData["FAX"] = calculateAverageByMethod(afterDataArray, "FAX");
          newAfterData["メール"] = calculateAverageByMethod(afterDataArray, "メール");
          newAfterData["持参"] = calculateAverageByMethod(afterDataArray, "持参");
          newAfterData["郵送"] = calculateAverageByMethod(afterDataArray, "郵送");
          newAfterData["システム"] = calculateAverageByMethod(afterDataArray, "システム");
          newAfterData["その他"] = calculateAverageByMethod(afterDataArray, "その他");
          
          // チャートを更新
          initOrUpdateChart(newBeforeData, newAfterData);
        }
      } 
      // 個人データの場合
      else if (id.includes('individual')) {
        if (window.__csvDataCache['individual_before.csv'] && window.__csvDataCache['individual_after.csv']) {
          console.log('個人データでチャートを更新します');
          
          // 個人データの集計処理
          const beforeDataArray = window.__csvDataCache['individual_before.csv'];
          const afterDataArray = window.__csvDataCache['individual_after.csv'];
          
          // ここでデータを集計
          newBeforeData["FAX"] = calculateAverageByMethod(beforeDataArray, "FAX");
          newBeforeData["メール"] = calculateAverageByMethod(beforeDataArray, "メール");
          newBeforeData["持参"] = calculateAverageByMethod(beforeDataArray, "持参");
          newBeforeData["郵送"] = calculateAverageByMethod(beforeDataArray, "郵送");
          newBeforeData["システム"] = calculateAverageByMethod(beforeDataArray, "システム");
          newBeforeData["その他"] = calculateAverageByMethod(beforeDataArray, "その他");
          
          newAfterData["FAX"] = calculateAverageByMethod(afterDataArray, "FAX");
          newAfterData["メール"] = calculateAverageByMethod(afterDataArray, "メール");
          newAfterData["持参"] = calculateAverageByMethod(afterDataArray, "持参");
          newAfterData["郵送"] = calculateAverageByMethod(afterDataArray, "郵送");
          newAfterData["システム"] = calculateAverageByMethod(afterDataArray, "システム");
          newAfterData["その他"] = calculateAverageByMethod(afterDataArray, "その他");
          
          // チャートを更新
          initOrUpdateChart(newBeforeData, newAfterData);
        }
      }
    }
  });
});

// 共有方法ごとの平均時間を計算する関数
function calculateAverageByMethod(dataArray, method) {
  if (!dataArray || dataArray.length === 0) return 0;
  
  const filteredData = dataArray.filter(item => 
    item["ケアプラン共有方法"] === method
  );
  
  if (filteredData.length === 0) return 0;
  
  const timeKey = "1ヶ月あたりの提供票作成時間（分）";
  const sum = filteredData.reduce((acc, item) => {
    const time = parseInt(item[timeKey]) || 0;
    return acc + time;
  }, 0);
  
  return sum / filteredData.length;
}
</script>

<style>
.chart-container {
  position: relative;
  width: 100%;
  max-width: 800px;
  margin: 0 auto 2rem auto;
  height: 400px;
}
</style>
